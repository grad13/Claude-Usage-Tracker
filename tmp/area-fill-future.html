<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Area Fill — Future Region Prototype</title>
<style>
  body { background: #1a1a1a; color: #ccc; font-family: system-ui; margin: 20px; }
  h2 { font-size: 14px; margin: 20px 0 8px; color: #aaa; }
  canvas { display: block; margin: 4px 0 16px; border-radius: 4px; }
  .row { display: flex; gap: 16px; align-items: flex-start; }
  .label { font-size: 11px; color: #888; margin-bottom: 2px; }
</style>
</head>
<body>

<h2>A. Current (no distinction)</h2>
<div class="row">
  <div><div class="label">5h</div><canvas id="a5" width="192" height="72"></canvas></div>
  <div><div class="label">7d</div><canvas id="a7" width="192" height="72"></canvas></div>
</div>

<h2>B. Diagonal stripes (future region)</h2>
<div class="row">
  <div><div class="label">5h</div><canvas id="b5" width="192" height="72"></canvas></div>
  <div><div class="label">7d</div><canvas id="b7" width="192" height="72"></canvas></div>
</div>

<h2>C. Lower opacity (future region)</h2>
<div class="row">
  <div><div class="label">5h</div><canvas id="c5" width="192" height="72"></canvas></div>
  <div><div class="label">7d</div><canvas id="c7" width="192" height="72"></canvas></div>
</div>

<h2>D. Stripes + lower opacity</h2>
<div class="row">
  <div><div class="label">5h</div><canvas id="d5" width="192" height="72"></canvas></div>
  <div><div class="label">7d</div><canvas id="d7" width="192" height="72"></canvas></div>
</div>

<script>
// Dummy data: usage steps as fraction of window [0..1] → percent [0..100]
const data5h = [
  { t: 0.05, pct: 3 },
  { t: 0.15, pct: 8 },
  { t: 0.25, pct: 12 },
  { t: 0.35, pct: 18 },
  { t: 0.45, pct: 22 },
  { t: 0.50, pct: 28 },
  { t: 0.55, pct: 35 },
];
const data7d = [
  { t: 0.02, pct: 5 },
  { t: 0.10, pct: 10 },
  { t: 0.20, pct: 15 },
  { t: 0.30, pct: 18 },
  { t: 0.40, pct: 22 },
  { t: 0.50, pct: 30 },
  { t: 0.60, pct: 38 },
  { t: 0.70, pct: 42 },
  { t: 0.75, pct: 48 },
];

const nowFrac = 0.65;   // current time at 65% of window
const resetFrac = 1.0;  // reset at right edge

const blue = { r: 100, g: 180, b: 255 };
const pink = { r: 255, g: 130, b: 180 };

function makeStripePattern(ctx, color, opacity) {
  const sz = 6;
  const pc = document.createElement('canvas');
  pc.width = sz; pc.height = sz;
  const px = pc.getContext('2d');
  px.fillStyle = `rgba(${color.r},${color.g},${color.b},${opacity * 0.4})`;
  px.fillRect(0, 0, sz, sz);
  px.strokeStyle = `rgba(${color.r},${color.g},${color.b},${opacity * 0.8})`;
  px.lineWidth = 1;
  px.beginPath();
  px.moveTo(0, sz); px.lineTo(sz, 0);
  px.stroke();
  return ctx.createPattern(pc, 'repeat');
}

function drawGraph(canvasId, data, color, baseOpacity, mode) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;

  // Background
  ctx.fillStyle = '#121212';
  ctx.fillRect(0, 0, w, h);

  // Ticks
  const divs = canvasId.endsWith('5') ? 5 : 7;
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth = 0.5;
  for (let i = 1; i < divs; i++) {
    const x = (i / divs) * w;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
  }

  // No-data gray: window start → first data point
  if (data[0].t > 0.01) {
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0, 0, data[0].t * w, h);
  }

  const nowX = nowFrac * w;
  const resetX = resetFrac * w;
  const lastPt = data[data.length - 1];
  const lastX = lastPt.t * w;
  const lastY = h - (lastPt.pct / 100) * h;
  const fillEndX = Math.max(resetX, lastX);

  // Build step path
  function buildStepPath() {
    const pts = data.map(d => ({ x: d.t * w, y: h - (d.pct / 100) * h }));
    const path = new Path2D();
    path.moveTo(pts[0].x, h);
    for (let i = 0; i < pts.length; i++) {
      if (i > 0) path.lineTo(pts[i].x, pts[i - 1].y);
      path.lineTo(pts[i].x, pts[i].y);
    }
    return { path, pts };
  }

  const { path, pts } = buildStepPath();

  if (mode === 'none') {
    // A: uniform fill to resetX
    const area = new Path2D(path);
    area.lineTo(fillEndX, lastY);
    area.lineTo(fillEndX, h);
    area.closePath();
    ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${baseOpacity})`;
    ctx.fill(area);

  } else if (mode === 'stripe') {
    // B: solid past, striped future
    // Past area (up to nowX)
    ctx.save();
    ctx.beginPath(); ctx.rect(0, 0, nowX, h); ctx.clip();
    const pastArea = new Path2D(path);
    pastArea.lineTo(nowX, lastY);
    pastArea.lineTo(nowX, h);
    pastArea.closePath();
    ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${baseOpacity})`;
    ctx.fill(pastArea);
    ctx.restore();
    // Future area (nowX to fillEndX) with stripes
    ctx.save();
    ctx.beginPath(); ctx.rect(nowX, 0, fillEndX - nowX, h); ctx.clip();
    const futArea = new Path2D();
    futArea.moveTo(nowX, h);
    futArea.lineTo(nowX, lastY);
    futArea.lineTo(fillEndX, lastY);
    futArea.lineTo(fillEndX, h);
    futArea.closePath();
    ctx.fillStyle = makeStripePattern(ctx, color, baseOpacity);
    ctx.fill(futArea);
    ctx.restore();

  } else if (mode === 'dim') {
    // C: solid past, dimmed future
    ctx.save();
    ctx.beginPath(); ctx.rect(0, 0, nowX, h); ctx.clip();
    const pastArea = new Path2D(path);
    pastArea.lineTo(nowX, lastY);
    pastArea.lineTo(nowX, h);
    pastArea.closePath();
    ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${baseOpacity})`;
    ctx.fill(pastArea);
    ctx.restore();
    // Future: lower opacity
    ctx.save();
    ctx.beginPath(); ctx.rect(nowX, 0, fillEndX - nowX, h); ctx.clip();
    const futArea = new Path2D();
    futArea.moveTo(nowX, h);
    futArea.lineTo(nowX, lastY);
    futArea.lineTo(fillEndX, lastY);
    futArea.lineTo(fillEndX, h);
    futArea.closePath();
    ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${baseOpacity * 0.4})`;
    ctx.fill(futArea);
    ctx.restore();

  } else if (mode === 'stripe-dim') {
    // D: solid past, striped + dimmed future
    ctx.save();
    ctx.beginPath(); ctx.rect(0, 0, nowX, h); ctx.clip();
    const pastArea = new Path2D(path);
    pastArea.lineTo(nowX, lastY);
    pastArea.lineTo(nowX, h);
    pastArea.closePath();
    ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${baseOpacity})`;
    ctx.fill(pastArea);
    ctx.restore();
    // Future: stripe + dim
    ctx.save();
    ctx.beginPath(); ctx.rect(nowX, 0, fillEndX - nowX, h); ctx.clip();
    const futArea = new Path2D();
    futArea.moveTo(nowX, h);
    futArea.lineTo(nowX, lastY);
    futArea.lineTo(fillEndX, lastY);
    futArea.lineTo(fillEndX, h);
    futArea.closePath();
    ctx.fillStyle = makeStripePattern(ctx, color, baseOpacity * 0.7);
    ctx.fill(futArea);
    ctx.restore();
  }

  // Usage dashed line
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.setLineDash([2, 2]);
  ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(0, lastY); ctx.lineTo(w, lastY); ctx.stroke();
  ctx.setLineDash([]);

  // Now marker (vertical thin line)
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 0.5;
  ctx.beginPath(); ctx.moveTo(nowX, 0); ctx.lineTo(nowX, h); ctx.stroke();
}

// A: no distinction
drawGraph('a5', data5h, blue, 0.7, 'none');
drawGraph('a7', data7d, pink, 0.65, 'none');
// B: stripes
drawGraph('b5', data5h, blue, 0.7, 'stripe');
drawGraph('b7', data7d, pink, 0.65, 'stripe');
// C: dim
drawGraph('c5', data5h, blue, 0.7, 'dim');
drawGraph('c7', data7d, pink, 0.65, 'dim');
// D: stripe + dim
drawGraph('d5', data5h, blue, 0.7, 'stripe-dim');
drawGraph('d7', data7d, pink, 0.65, 'stripe-dim');
</script>
</body>
</html>
